---
title: "L1 taxonomic harmonization"
author: 
  - Phoebe L. Zarnetske
  - Patrick Bills
format:
  html:
    toc: true
    toc-depth: 3
    embed-resources: true
editor: source
date: 11/06/2025
date-format: iso
---

## Avian Interaction Pairs Data: L0 to L1 taxonomic harmonization

### About

- **PROJECT:** Avian Interaction Database
- **COLLABORATORS:** Vincent Miele, Stephane Dray
- **Run Date:** `r Sys.Date()`

### Data inputs:

**Avian Interaction Database L0**

Raw Data, combined (stitched) and with content
cleaning but taxonomic names as entered (older names, typos, etc)

*Set the interactions database file to read from here:*

( output From `R/L0/2_stitch_species.R` )

```{r}
# Clear all existing data
rm(list=ls())

AvianInteractionData_L0_file <-  "ain_all_raw.csv"

```


**Main Checklists:**

- Full 2024 Clements/eBird list 
- GBIF database (via taxadb package)

Curated Species checklist: 

- Current selected species list =
  combined checklist based on Clements/eBird v2024, Avibase v8.17, BBS v2024:
  output from `R/L0/AvianInteractionData_specieslists_L1.R` (global) or
  `R/L0/3_subset_species_lists.R` (North America)
  - used for species lookup / matching

**Manual Taxonomic Resolution Overrides Table:**

- Rows of corrections to be applied to L0 data for updating species 
as entered to match the current checklist.  Update the code below 

```{r}
#| echo: false

manual_taxonomic_resolutions_file_name<- here::here('R/L1', "aux_taxonomy_resolutions_202510.csv")
```



### DATA OUTPUT:

Taxonomic Resolution Table: 

Avian Interaction Database, cleaned and with taxonomic names resolved to 
match checklists listed above: `ain_all.csv`

```{r}
AvianInteractionData_L1_file <- "ain_all.csv" 

today_date_string <- format(Sys.Date(),"%Y-%m-%d")
AvianInteractionData_L1_taxonomy_table_file <- "aux_taxonomy_resolutions.csv"

```


### Next script to run: 

- 5_subset_network.qmd - this cleans further (e.g., breeding/non-breeding) and some of that needs to go in general cleaning (either here or in another script).


### NOTES

This script is used to refine species name changes to align with the 
Clements & eBird checklist to create an Rdata file.  

Currently, the script is working for a checklist of CONUS+Alaska+Canada.  

L0 data are checked to assign updated scientific and common names to the interaction pairs data. Makes a new column that also includes scientific name changes associated with the AOUcombo.index for merging with those names in the AvianInteractionData_AOUindex_L1.csv


GOOD EXAMPLE TO TRACE MATCHING: Aeronautes saxitalis should be Aeronautes saxatalis

### Workflow Summary

At each step, resolution narrows down those names that require manual entry 
in a table to identify the current accepted name in checklist

1. setup 
   - read in checklists and L0 data (int.raw)
   - final data cleaning to ensure no typos etc
   - create a name resolution table to be completed (int.raw.names)
2. fix missing scientific names manually 
3. resolve scientific names already exactly matching checklist 
4. for those names not resolved, use fuzzy matching to find scientific names in checklist (high confidence only)
5. for those names not resolved, match common names with checklist (high confidence only)
6. for those names not resolved, use GBIF to see if name can be resolved to a checklist name
7. read in CSV of manual resolutions and apply to whole list 
8. resolve genus only unids
9. resolve hybrids ( X and / )
10. merge checklist common names into resolutions matching on scientific name
11. join checklist scientific names and common names to interactions data
12. save data files 
    - interaction data with checklist names resolved 
    - resolutions table with explanations

### Versions

-   Original R script `AvianInteractionData_L1.R` 27 Oct 2022 (PLZ)
-   updated through 12 Dec 2024 (PLZ);
    -   As of Dec. 12, 2024, this is mainly cleaned for BBS species
-  May 2025- July 2025 convert to workflow notebook/Quarto, (PSB)
-  August 2025, using new species lists Canada+CONUS from PLZ (PSB)
-  September 10, 2025, using species lists from commit from PLZ (PSB)
-  Oct 1, 2025: workflow reorganization for better taxonomic resolution (PSB; PLZ edits and checks


## TO DO / Notes

complete code to apply CSV of resolutions to file

code/function to checklist to be able to be moved around

perhaps also include the species code from Clements in the final taxonomy table 
so that it can be looked up next year directly to see if scientific name has changed

read the original 2024 list, not my version that has 2023/22 links (does not add rows)

add code to get the timestamp for the L0 file and report that here


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Data Set-up

File paths used for this run:

```{r}
#| echo: false

# functions used by all 
source(here::here('R/lib/shared_functions.R'))
# functions for this process to reduce this script size
# and load libraries used here
source(here::here('R/lib/taxonomy_functions.R'))

file_paths <- get_file_paths()

print(file_paths)
```

*Note that the Checklist folder above is in L0 which contains species lists, 
but the subset list for 2024-25 analysis is in L1 as it's built from L0 lists*

### Setup: Checklists

#### Curated List

**Previously:** all species in BBS `"bbs_splist_2024_L1.csv"`

(the 2024 BBS release includes all species as of 2023 BBS surveys, plus the additional 
AOUcombo.index column (= lumps BBS subspecies into species)for use w BBS AOU index)

`splist2024<-read.csv(file.path(L1_dir,"bbs_splist_2024_L1.csv"))`

**Current**

September 2025: new curated list curated by PLZ using Clements, AVIBase, BBS etc. 
See `R/L1/3_subset_species_lists.R`

```{r}

current_species_list_filename <- "spp_joint_cac.csv"
splist2024_filepath <- file.path(file_paths$CHECKLIST_L1,current_species_list_filename )
splist2024 <- read.csv(here::here(splist2024_filepath))
print(paste("Read in ", nrow(splist2024), "entries from checklist file", splist2024_filepath))

```

#### Main Checklist

Read in the full check list the official eBird/Clements v2024 checklist

```{r}
#| label: read_clements


checklist_filename <- "eBird-Clements-v2024-integrated-checklist-October-2024-rev.csv"
checklist.orig <- read.csv(here::here(file.path(file_paths$CHECKLIST_L0,checklist_filename)))
print(paste("Read in ", nrow(checklist.orig), "entries from checklist file", checklist_filename))
```

amend column names of checklist to match for merging later show col name before and after change

```{r}
print(names(checklist.orig))
checklist <- checklist.orig
names(checklist)[names(checklist) == "scientific.name"] <-"scientific_name"
names(checklist)[names(checklist) == "English.name"] <-"common_name"
print("CORRECTED CHECKLIST COLUMNS:")
print(names(checklist))
```


**SET HOW WE FIND 'SPECIES' IN CHECKLIST**

The Clements checklist includes families, species, hybrids, etc.   In several
places below we want to find only the 'species' which include a few 
categories.  This variable is used in several places in this notebook
to search only 'species' in the checklist 

```{r}
species_categories <- c("group (monotypic)","species","slash","subspecies","genus","family")

```

```{r}
#| echo: false

# cheap function using global var checklist to make it easy
on_checklist <- function(sciname){
  rows<- filter(checklist, scientific_name == sciname)
  if(nrow(rows)>0 ) return(TRUE)
  
  return(FALSE)
}
```
#### Interactions Data

To use a different or test files, edit this L0 filename:

```{r}
full_path_stitched_file <- file.path(file_paths$L0,AvianInteractionData_L0_file)
int.raw<-read.csv(full_path_stitched_file)
print(paste("read in ", nrow(int.raw), "records from ", full_path_stitched_file))
```

### Final Interaction Data Cleaning/Corrections

Most of these filters and adjustments are now made during the 2_stitch_species process
but were are ensuring the data is clean prior to matching taxonomy


#### Remove blank rows

```{r}
before_filter_nrow <- nrow(int.raw)
int.raw <- filter(int.raw,!(is.na(species1_scientific)& 
                             is.na(species2_scientific) & 
                             is.na(species1_common) & 
                             is.na(species2_common)
                           ))

print( paste(as.integer(before_filter_nrow - nrow(int.raw)), "blank rows removed"))
```

#### Trim white space from all names columns

```{r}
# trim white space

int.raw <- dplyr::mutate(int.raw, 
                         species1_scientific = trimws(species1_scientific,which=c("right")), 
                         species2_scientific = trimws(species2_scientific,which=c("right")), 
                         species1_common = trimws(species1_common,which=c("right")),
                         species2_common = trimws(species2_common,which=c("right"))
) 

print("unique scientific name combos after removing white space")
print(length(unique(paste(int.raw$species1_scientific, int.raw$species2_scientific))))
```

#### Missing Scientific name check

Are there any records that are missing a scientific name for species1?

*if so this is problematic for adjusting the recorded name with the checklist 
name, and should be corrected in data entry files*

```{r}
records.missingsp1 <- int.raw[is.na(int.raw$species1_scientific),]
tibble(records.missingsp1)
```

Records missing a scientific name for sp2

```{r}
records.missingsp2 <- int.raw[is.na(int.raw$species2_scientific),]
tibble(records.missingsp2)

```

Are there rows that have *only* common names for both sp1 and sp2?

```{r}
 
int.common_names_only <- dplyr::filter(int.raw, is.na(species1_scientific) & is.na(species2_scientific))
  
print(nrow(int.common_names_only))
```

#### remove rows that do not have interactions

*These should be corrected in the L0 correct process, 
but catch them here before correcting taxonomy*

List rows with both interaction columns missing

```{r}
#| echo: false
# to allow us to re-run this, look to see if we saved the var with all rows
# because we've run the cells below, and if so, reset our main df to that one
if(exists("int.raw.saved_all_rows")) int.raw<- int.raw.saved_all_rows

print("n rows with both effects missing:")
print(nrow(filter(int.raw, is.na(effect_sp1_on_sp2) & is.na(effect_sp2_on_sp1))))
print("n rows with at least one effect present:")
print(nrow(filter(int.raw, !is.na(effect_sp1_on_sp2) | !is.na(effect_sp2_on_sp1))))
print("list of rows with both effects missing:")
```

Table of rows with both effects missing:

```{r}
#| echo: false

tibble(filter(int.raw, is.na(effect_sp1_on_sp2) & is.na(effect_sp2_on_sp1)))
```

Remove those with no interactions (if any)
```{r}

# save the original full list in case we need to check again
int.raw.saved_all_rows <- int.raw

int.raw <- filter(int.raw, !is.na(effect_sp1_on_sp2) | !is.na(effect_sp2_on_sp1))
print("rows remaining with not both effects NA:")
print(nrow(int.raw))
```

#### Some quick typo fixes

This is the same function run during stitching, but run it again and to ensure 
nothing was missed when it was run during L0.  Shouldn't really find anything else

```{r}

# int.raw1<-fix_taxon_typos(int.raw) 
# See what is different between int.raw and int.raw1 using the diffdf package:
# diffdf(int.raw, int.raw1)
# Should be finding editorial differences involving "."
# Oct 5: found 12 rows that differ in some way (spaces and "." ",")
int.raw<-fix_taxon_typos(int.raw)
```


#### Discovery and repair of missing Sp1/Sp2 scientific names

List rows with missing sp1 values but have other data to use for fix

```{r}
records.missingsp1 <- int.raw[is.na(int.raw$species1_scientific),]
print(records.missingsp1)
```

Fix these missing species directly by matching the common_names from checklist

```{r}
#| echo: false
 
for(common_name_for_missingsp1  in records.missingsp1$species1_common){
  print(common_name_for_missingsp1)
  
  matching_sp<- checklist %>% 
    dplyr::filter(common_name == common_name_for_missingsp1) %>% 
    dplyr::select(common_name, scientific_name)  
  
  print(as.vector(matching_sp[1,]$scientific_name))
  # print(subset(checklist, common_name == common_name_for_missingsp1))
}
```


Assign scientific names to all rows for those common names that have missing sp1 scientific names, create a Manual Assignment structure here:

```{r}
#| echo: false
manual_assignments = list()
manual_assignments[["Rhinoceros Auklet"]] <- "Cerorhinca monocerata"

print(manual_assignments)
# add more as needed  
```

apply the manual assignments

```{r}
for(cname in names(manual_assignments)){
  print(paste("set records with common name", cname, "to sp1 = ", manual_assignments[[cname]]))
  print("n rows to update:")
  print(nrow(int.raw[int.raw$species1_common == cname & is.na(int.raw$species1_scientific),]))
  int.raw[
    int.raw$species1_common == cname & 
    is.na(int.raw$species1_scientific),
    ]$species1_scientific = manual_assignments[[cname]] 
}

  
```

double check: remaining records with **missing sp1:**

```{r}
records.missingsp1 <- int.raw[is.na(int.raw$species1_scientific),]
print(records.missingsp1)  
```

### Discovery and repair of missing Sp2 scientific

rows with missing **sp2 scientific**:

```{r}
records.missingsp2<- int.raw[is.na(int.raw$species2_scientific),]
print(records.missingsp2)
```


Saved outcome from Previous run
```         
May 2025: 2 rows need editing 
species1_common species2_common         species1_scientific
866         White-cheeked Pintail   Cinnamon Teal Anas bahamensis rubirostris
14223 Middle American Screech-Owl            <NA>        Megascops guatamalae
species2_scientific effect_sp1_on_sp2 effect_sp2_on_sp1          interaction
866                  <NA>                 1                 1 facilitation-feeding
14223                <NA>                NA                NA                 <NA>
one had both NA interactions , now we are removing those
```



List the names from the checklist that match those missing in sp2:

```{r}
#| echo: false
#| 
for(common_name_for_missingsp2  in records.missingsp2$species2_common){
  print(checklist %>% 
    dplyr::filter(common_name == common_name_for_missingsp2) %>% 
    dplyr::select(common_name, scientific_name))
}
```

**Sp2 fix list**

Update this list of fixes as errors are discovered above.

Note that the common names will be update updated below with the checklist.

```{r}
#| echo: false
manual_assignments = list()
manual_assignments["Cinnamon Teal"] <-  "Spatula cyanoptera"
# add more as needed  
print(manual_assignments)
```

fix sp2 using the list above

```{r}
# species2 fixes using the list above
for(cname in names(manual_assignments)){
  print(paste("set records with common name", cname, "to sp2 = ", manual_assignments[[cname]]))
  print("n rows to update with this command name and missing sp2:")
  rows_to_fix <- nrow(
    int.raw[int.raw$species2_common == cname & is.na(int.raw$species2_scientific),]
  )
  
  print(rows_to_fix)
  if(rows_to_fix > 0 ){
  int.raw[
    int.raw$species2_common == cname & 
    is.na(int.raw$species2_scientific),
    ]$species2_scientific = manual_assignments[[cname]] 
  }
}
  # double check remaining rows with missing sp2 (should be zero)
```

Double check that there are no remaining rows with missing scientific names

```{r}
tibble(int.raw[is.na(int.raw$species2_scientific),]) 
```
*completed fixes for missing scientific names*








--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Taxonomy Adjustments Table

**Create new data frame of all names, as is in the raw file, and what is to be 
adjusted/updated/assigned.


Column Definitions:

- scientific_name.raw : L0 name as it appears in the original CSV file (stitched)
- common_name.raw : L0 name as it appears in the original CSV file (stitched)
- scientific_name_clements2024 : L1 name to be used (pre checklist )
- common_name_clements2024 : L1 name to be used (pre checklist )
- edit_notes: text of why edits were made

The edit columns are based on the Clements 2024 checklist.
Determine how many unique entries are in int.raw\$species1_scientific, which 
are unique combos of scientific names.

```{r}
unique.sp.raw <- data.frame(scientific_name.raw = with(int.raw, union(
  species1_scientific, species2_scientific
)))

print(dim(unique.sp.raw)) #3913 # May 29, 2025: 3889; Sept. 29, 2025: 3879; Oct 26: 3873
```


**Create Name Edits Table**

Create list of unique scientific_name.raw and common_name.raw pairs with 
formatting adjustments, stacking and collecting anything in sp1 and sp2. 
See documentation in `taxonomy_functions.R` script for details

*note:  since adjustments/corrections to species were added to L0 cleaning 
process, there should be very few differences between 'raw' and 'edited' 
names at this point in the process*


```{r}
## create the raw <- edit adjustments table 
int.raw.names <- create_names_edit_table(int.raw)
head(tibble(int.raw.names))
```


Number of unique species in taxonomy edits table  - no resolutions made yet

```{r}
#| echo: false
#| output: true

nrow(unique(unresolved_species(int.raw.names)))

```

Historical numbers of unresolved species:
May 2025: 3889
Sept 2025: 3876
Oct 2025: 3876


Test case to track with known misspelling: Accipiter cooperi was misspelled (should be Accipiter cooperii) - exists in int.raw.names

```{r}
known_misspellings <- c("Accipiter cooperi")
tibble(dplyr::filter(int.raw.names, scientific_name.raw %in% known_misspellings))
```

expected output:

```         
scientific_name.raw common_name.raw scientific_name.edit common_name.edit
1 Accipiter cooperi   Cooper's Hawk  Accipiter cooperi    Cooper's Hawk
```



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

### Example Checking process:


Discovery that Dendroica pinus - Pine Warbler - genus was updated to Setophaga pinus

checklists for the old and then new name FOR THIS SPECIES

```{r}
scientific_name.raw <- "Dendroica pinus"

```

is this is being used? records with old name: 
```{r}
#| echo: false
#| output: true
print(interaction_count_by_species(int.raw,scientific_name.raw  ))

```
records with new name:
```{r}
#| echo: false
#| output: true

print(interaction_count_by_species(int.raw, "Setophaga pinus"))
```

Which is preferred on the checklist?
```{r}
checklist[which(checklist$scientific_name == "Dendroica pinus"), ] # no records
checklist[which(checklist$scientific_name == "Setophaga pinus"), ] # one record
```

Is there an entry in our name edit table with the old genus?
```{r}
tibble(int.raw.names[int.raw.names$scientific_name.raw == "Dendroica pinus",])
```

add edited name and note

```{r}
int.raw.names <- add_name_edits(edits.df = int.raw.names,
               scientific_name.raw = "Dendroica pinus", 
               scientific_name.edit = "Setophaga pinus",
               edit_notes = "Update to new checklist name"
)
```











--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Checklist matches

Identify those species from the database that are already on the latest checklist
and add a note to track those. These do not need to be resolved. 


```{r}

# update in place

on_checklist_note <- "L0 species as entered on checklist (Clements 2024)"

checklist.species <- checklist[checklist$category %in% species_categories, "scientific_name"]

# make a copy
int.raw.names.checklist_match <- int.raw.names
# add note when it matches
int.raw.names.checklist_match[int.raw.names$scientific_name.edit %in% checklist.species, ]$edit_notes <- on_checklist_note

print(unresolved_species(int.raw.names.checklist_match))

```

#### L0 Checklist matching Summary

Number rows with species already on the checklist, so already resolved, which includes
full species and subspecies, but not slashes, unids, families or hybrids

```{r}
#| echo: false
#| output:true

nrow(filter(int.raw.names.checklist_match, !is.na(edit_notes) ))
```


Unique scientific names in the database NOT matched to the checklist : 
```{r}

nrow(unique ( unresolved_species(int.raw.names.checklist_match)))

```
September 2025: 545 rows 
October 5, 2025: 429 rows

### save to actual list and continue

```{r}
int.raw.names <- int.raw.names.checklist_match
```


Remaining (unique) scientific names to resolve: 

```{r}
#| echo: false
#| output: true

length(unique(unresolved_species(int.raw.names)$scientific_name.raw))

```
September 2025: 504 (just about 30 redundant common names)
October 6, 2025: 404







--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Fuzzy Matching of Scientific Name to checklist

Use fuzzy logic function ( see lib/taxonomy_functions.R ) to find closest match from the CHECKLIST reference list
Function to find the closest match with a similarity score, try and determine what misspellings exist 


#### Reference list of scientific names from eBird Clements CHECKLIST 2024**

Create a reference list from our Checklist read in above (Clements)

```{r}


# checklist.species<- filter(checklist, category == "species" | category == "slash" | category == "subspecies")
checklist.species<- filter(checklist, category %in% species_categories)

reference_names <- tibble(
  scientific_name = checklist.species$scientific_name,
  common_name = checklist.species$common_name
)
nrow(reference_names)

```
#### Number of names to resolve: 

```{r}

print(length(unique(unresolved_species(int.raw.names)$scientific_name.edit)))
```
### Resolve matches based on scientific_name.edit and Clements Checklist

Calculate the fuzzy match score and closest name in the checklist for 
each record in the unresolved names

*To examine the matches created by this process use `View(scientific_name_matches)`*

*(this takes several minutes to complete)*

```{r}
# prepare a data frame to fill up with match data with current unresolved species
scientific_name_matches <- unresolved_species(int.raw.names)
# add new columns
# tracking original row number will make subsetting and cross-ref easier later
scientific_name_matches$row_number <- unresolved_species_rows(int.raw.names)
scientific_name_matches$closest_scientific_name_match <- NA
scientific_name_matches$scientific_name_match_score <- NA


# fill them in one row at a time
for(r in 1:nrow(scientific_name_matches)) {
  # optional, print the name we are on to gauge progress
  # print(scientific_name_matches[r,"scientific_name.edit"])
  fuzzy_match <- find_closest_match_with_score( scientific_name_matches[r,"scientific_name.edit"], checklist$scientific_name)
  scientific_name_matches[r,]$closest_scientific_name_match <- fuzzy_match$match
  scientific_name_matches[r,]$scientific_name_match_score <- fuzzy_match$score
}

# idea to improve speed: rewrite scientific_name_matches to accept a vector/list of names 
# and return list of lists, then rbind/cbind

tibble(scientific_name_matches)
```

Distribution of Match Scores

```{r}
suppressMessages(suppressWarnings(library(ggplot2))) # don't print to console
g<- ggplot(scientific_name_matches, aes(scientific_name_match_score)) +  
        geom_histogram(binwidth=0.01, color = "#000000", fill = "#0099F8") # + 

print(g)

```


Test of checklist and data : Accipiter cooperi is misspelled AND has been changed to Astur, 
so the match is not even the same  - should have a match of about 0.84

```{r}

incorrect_sp_to_check <-"Accipiter cooperi" 
print(dplyr::filter(scientific_name_matches, 
                    scientific_name.raw %in% c(incorrect_sp_to_check))$scientific_name_match_score)
```



#### Scientific Name Matching Set High Confidence threshold

To review fuzzy match results on unresolved names, run `View(scientific_name_matches)`

PLZ Oct 5: after reviewing, and ordering from 1.0 to 0, found that Cercotrichas coryphoeus
Karoo Scrub-Robin (0.92555990) was the first that did not match.

After review of matches, all of the matches with score > 0.95 looked correct, 
and many but not all in range from 0.095 > score > 0.90 so those need to be checked. 
PLZ Oct 5: after reviewing, and ordering from 1.0 to 0, found that Cercotrichas coryphoeus
Karoo Scrub-Robin (0.92555990) was the first that did not match because Genus changed (to Tychaedon).

Setting the threshold to 0.95 for automatic assignment, and will add common name 
matching to increase confidence in the others.

```{r}
high_confidence_threshold <- 0.95
```

Number of unique species with high confidence matches (scientific_name_match_score >= `{r} high_confidence_threshold` )

```{r}
#| echo: false
#| output: true
high_confidence_matches <-  filter(scientific_name_matches, 
                                   scientific_name_match_score >= high_confidence_threshold
                                   )
print(length(unique(high_confidence_matches$scientific_name.raw)))
proportion_high_confidence = length(unique(high_confidence_matches$scientific_name.raw)) / length(unique(scientific_name_matches$scientific_name.raw))
print(sprintf("%.2f%%", round(proportion_high_confidence*100,2)))
```
*previous results:*

`Dec 2024: 257 out of 326; May 29, 2025: 244 out of 309`

Sept 2025:
  - >= 0.95 134 (33%)
  - >= 0.90 211
Oct 2025:
  - >= 0.93 166 (41.09%)
Oct 26, 2025:
  - >= 0.95 134 (33.17%) - same as Sept
  
### Resolve (assing edit_note to all high confidence matches)

```{r}

edit_note <- "high confidence str match to checklist (Clements 2024) "


# make a copy
int.raw.names.matches <- int.raw.names

# fill the matching rows with the matched sci names
# this assignment works becuase the match data frame contains the original row numbers
int.raw.names.matches[high_confidence_matches$row_number,]$scientific_name.edit<- high_confidence_matches$closest_scientific_name_match
int.raw.names.matches[high_confidence_matches$row_number,]$edit_notes <- paste( edit_note, round(high_confidence_matches$scientific_name_match_score,3))

# to review these assignments, run View(int.raw.names.matches) which includes all resolutions
```

Remaining species to resolve after high-confidence scientific name match:

```{r}
#| echo: false
#| output: true
print("unresolved rows in names table:")
print(length(unresolved_species_rows(int.raw.names.matches)))
print("unresolved unique scientific names ")
print(length(unique(unresolved_species(int.raw.names.matches)$scientific_name.raw)))

```

```{r}
#| echo: false
# after review, save these resolutions back to main list variable
int.raw.names <- int.raw.names.matches
rm(int.raw.names.matches)
```



### Fuzzy match lower confidence matching


```{r}

medium_confidence_threshold <- 0.90
minimum_confidence_threshold <- 0.80

medium_confidence_matches <- filter(scientific_name_matches, 
                                     scientific_name_match_score < high_confidence_threshold & 
                                     scientific_name_match_score >= medium_confidence_threshold)

low_confidence_matches <- filter(scientific_name_matches, 
                                     scientific_name_match_score < medium_confidence_threshold & 
                                     scientific_name_match_score >= minimum_confidence_threshold)

```

### Determine lower confidence threshold

After review it appears that names may be matched correctly at a lower threshold
than some names matched incorrectly (at higher threshold), that is, it's a mix
from in matches from 0.90 - 0.95. 

Hold these and match on common name first, then re-run fuzzy matching

skip this because the histogram above shows this information. 
```{r}
# score_start <- min(high_confidence_matches$scientific_name_match_score)
# score_end <- max(high_confidence_matches$scientific_name_match_score)
# increment <- 0.005
# 
# # collect these in a list for exploring
# confidence_partition <- list()
# 
# # Loop through each score range and print the matches within that range
# for (i in seq(score_start, score_end, by = increment)) {
#   current_range <- high_confidence_matches %>%
#     filter(scientific_name_match_score >= i & scientific_name_match_score <= i + increment)
#   
#   # Print the current range if it has any entries
#   if (nrow(current_range) > 0) {
#     low_range <- sprintf("%.2f", i)
#     high_range <- sprintf("%.2f", i + increment)
#     range_text = paste(low_range, "to", high_range)
#     print(paste("Match Score Range:",range_text ,": ", nrow(current_range), "records"))
#     confidence_partition[[high_range]]<- current_range
#     # print(current_range, n=100) # print up to 100 rows in a section
#   }
# }
# 
# ```
# View any of these dataframes using the partition list to see what's on there
# ```{r}
#  confidence_partition[["0.91"]]
```


---

## CHECKPOINT: save current workspace with current date

```{r}

# today_date_string <- format(Sys.Date(),"%Y-%m-%d")
# rdata_file_name <- paste0("AvianInteractionData_L1_workspace", today_date_string, ".RData")
# save.image(file.path(file_paths$L1,rdata_file_name ))
```





--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Match on Common names

after applying high-confidence matches, try matching on common names using 
the same technique. 

Exact matches will have fuzzy match score=1.0, but just less coding to go through
the whole matching process instead of direct match and then fuzzy match

```{r}
on_checklist_note <- "L0 species matched by common name to checklist (Clements 2024)"

# species_categories defined in checklist reading section above
checklist.common<- filter(checklist, category %in% species_categories)$common_name
```

Build the common name matching table

```{r}
# create list of names to match from unresolved rows
name_matches<- unresolved_species(int.raw.names)
# add new columns
name_matches$row_number <- unresolved_species_rows(int.raw.names)
name_matches$closest_name_match <- NA
name_matches$name_match_score <- NA
name_matches$scientific_name.checklist <- NA

# fill them in one row at a time
for(r in 1:nrow(name_matches)) {
  # optional, print the name we are on to gauge progress
  # print(scientific_name_matches[r,"scientific_name.edit"])
  
  raw_common_name<-name_matches[r,"common_name.raw"] 
  fuzzy_match <- find_closest_match_with_score(raw_common_name, checklist.common)
  
  # find the associated sci name, but only look at species records 
  # (some groups have the same common name for the whole genus)
  scientific_name_lookup <- as.character(filter(checklist, 
                                    common_name == fuzzy_match$match & category %in% species_categories ) %>%   
                          select(scientific_name))
  if(length(scientific_name_lookup) == 0) warning(paste(" no scientific name in checklist for ",fuzzy_match$match))
  else {
    name_matches[r,]$closest_name_match <- fuzzy_match$match
    name_matches[r,]$name_match_score <- fuzzy_match$score
    name_matches[r,]$scientific_name.checklist <- scientific_name_lookup 
  }
}
```

To view this table, run `View(name_matches)`

#### Example Matches

Considerations for setting the threshold (September 2025)

- *Northern Jancan* matches *Northern Jacana* 0.9458333	=> correct
- *Black-Winged Babbler*	matches *Black-chinned Babbler*	0.9190476 => incorrect 
- *Cackling/Canada Goose* matches *character(0)* 0.9099206 => incorrect (should be Branta hutchinsii/canadensis)

Conclusion setting threshold for match scores minimum 0.940 for high-confidence matches
which corrects a good number of species.  

```{r}
common_name_match_threshold <- 0.94
```



Update name edits using common name matches

```{r}
#| echo: false

high_confidence_common_matches <- filter(name_matches, name_match_score >= common_name_match_threshold)

# update by Row number. Not very R-like but works
# get the row numbers of names list already updated -> this process will not overwrite existing notes
# if following the notebook in order, these are mutually exclusive, but this ensures it could be 
# run out of order
rows_with_non_empty_notes <- which(!is.na(int.raw.names$edit_notes))

rows_to_update <- setdiff(high_confidence_common_matches$row_number, rows_with_non_empty_notes) # [!rows_high_confidence_match  %in% rows_with_non_empty_notes ]

print(paste("updating", length(rows_to_update), "rows"))

common_match_note <- "high confidence common name fuzzy match (Clements 2024) "

# make a copy (since matching takes a while)
int.raw.names.matches<- int.raw.names
# using saved row numbers, update scientific_name.edit and edit_note in bulk
int.raw.names.matches[high_confidence_common_matches$row_number,]$scientific_name.edit<- high_confidence_common_matches$scientific_name.checklist
# paste in the confidence level of these matches
int.raw.names.matches[high_confidence_common_matches$row_number,]$edit_notes <- paste( common_match_note, round(high_confidence_common_matches$name_match_score,3))


```

Remaining unresolved rows after high confidence scientific and common name matches

```{r}
#| echo: false
#| output: true
print("unresolved rows in names table:")
print(length(unresolved_species_rows(int.raw.names.matches)))
print("unresolved unique scientific names ")
print(length(unique(unresolved_species(int.raw.names.matches)$scientific_name.raw)))

```

```{r}
#| echo: false
#| output: true

# after review, copy these resolve to the main names list
int.raw.names <- int.raw.names.matches
```





--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Optional, Save the unresolved 

Save our current unresolved species (prior to GBIF matching) in order to import
into a spreadsheet to build a fixes table the first time. 

This maybe useful for comparison in future years

First, add a custom column with some notes
```{r}
int.raw.names.unresolved <- unresolved_species(int.raw.names)
int.raw.names.unresolved$row_number <- unresolved_species_rows(int.raw.names)
int.raw.names.unresolved$comments <- ""

## add a comment with the match score for common name
# first create the comment to use linked by row number we saved during that process
common_name_match <- filter(name_matches, row_number %in% int.raw.names.unresolved$row_number) %>%
    mutate(comment = paste("common name match: ", closest_name_match, round(name_match_score,2), scientific_name.checklist, ";")) %>% select(row_number, comment)
# update the comment, linking on row number
int.raw.names.unresolved<- mutate(int.raw.names.unresolved, comments = paste(comments, common_name_match[common_name_match$row_number == row_number, "comment"]))

## add comment with the match score for scientific name
# first create the comment to use linked by row number we saved during that process
scientific_name_match <- filter(scientific_name_matches, row_number %in% int.raw.names.unresolved$row_number ) %>%
  mutate(comment = paste("scientific name match: ", closest_scientific_name_match, round(scientific_name_match_score,2),";")) %>% 
  select(row_number, comment)
  
# add this match score to the comments in our unresolved list
#int.raw.names.unresolved
int.raw.names.unresolved<- mutate(int.raw.names.unresolved, 
           comments = paste(comments, scientific_name_match[scientific_name_match$row_number == row_number, "comment"]))

```

Optional: Save CSV of our current unresolved species

```{r}
today_date_string <- format(Sys.Date(),"%Y-%m-%d")
temp_file_name <- paste0("unresolved_L1", today_date_string, ".csv")
write.csv(int.raw.names.unresolved, file=file.path(file_paths$L1,temp_file_name ), row.names = FALSE)
print(paste("saved ", file.path(file_paths$L1,temp_file_name )))
```













--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


## TaxaDB and GBIF Matching

taxadb package: Modified from this code:
https://docs.ropensci.org/taxadb/articles/intro.html 

In previous code, tried ITIS and COL to see if they were better than GBIF. 
GBIF has the fewest NA values, so we are sticking with it (it is the most comprehensive).

The GBIF database is frequently at odds with the Clements checklist.  Taxadb will
help find synonyms for a scientific name, but the result is often not on the checklist. 

However, it may be good at finding a handful of synonyms that _are_ on the checklist. 

This process takes the remaining unresolved names, finds the accepted GBIF name for them, 
and if that name is also on Clements, that is what will be assigned


### Create a local GBIF database

Create a local gbif database in :
```{r}
taxadb::td_create("gbif")
```

Resolve scientific names for the scientific names, 
based on scientific_name.edit using GBIF

```{r}
int.gbif.names <- unresolved_species(int.raw.names) %>%
  mutate(
    scientific_id = taxadb::get_ids(scientific_name.edit, "gbif"),
    accepted_scientific_name = taxadb::get_names(scientific_id, "gbif")
  )
warnings()
```
**list join warnings**

For those entries that are ambiguous (\> 1 match of the edited species with gbif),
a warning will be issued. This loops through those warnings and prints 
the message that has the species in question so we can view and capture it.

```{r}

ws<- dplyr::last_dplyr_warnings()
print(paste("there are ", length(ws), "species have >1 identifier and need to be resolved w BOW"))

for( w in ws) print(w$parent)
```

IF there are duplicate matches (there will be warnings here)


###  TaxaDB/GBIF Edits review

of unresolved, how many had GBIF matches:

```{r}
#| echo: false
#| output: true

print(
  paste(
    nrow(filter(int.gbif.names, !is.na(scientific_id) )),
    "of",
    length(unresolved_species_rows(int.raw.names))
  )
)
```

How many of those gbif matches are actually on the checklist?

```{r}
#| echo: false
#| output: true

# checklist.species is defined above for other matching 
gbif_on_checklist <- filter(int.gbif.names, accepted_scientific_name %in% checklist.species$scientific_name )
print(nrow(gbif_on_checklist))
```

*TO-DO* 

we know it is suggesting Gallus gallus for chicken but that is not correct 
by checklist, so remove all of those 

```{r}
gbif_on_checklist <- filter(gbif_on_checklist, accepted_scientific_name != 'Gallus gallus')
print(nrow(gbif_on_checklist))
```


apply these changes 

```{r}
# make a copy 
int.raw.names.gbif <- int.raw.names
# just use a loop through gbif matches to update 
for(r in 1:nrow(gbif_on_checklist)){
  names_row <- which(int.raw.names.gbif $scientific_name.raw == gbif_on_checklist[r,"scientific_name.raw"] & 
                int.raw.names.gbif $common_name.raw == gbif_on_checklist[r,"common_name.raw"])
  
  int.raw.names.gbif[names_row, ]$scientific_name.edit <- gbif_on_checklist[r,]$accepted_scientific_name
  gbif_note <- paste("GBIF: Match using taxadb/", gbif_on_checklist[r,]$scientific_id, " on checklist (Clements 2024)")
  int.raw.names.gbif[names_row, ]$edit_notes <- gbif_note
}
                  
  
```

Review outcome of applying GBIF
```{r}
tibble(filter(int.raw.names.gbif, grepl("GBIF", edit_notes)))
```

After Review, save copy back to taxonomy table variable

```{r}
int.raw.names <-  int.raw.names.gbif 

```


Remaining species to resolve after fuzzy and gbif matching:

```{r}
#| echo: false
#| output: true
print("unresolved rows in names table:")
print(length(unresolved_species_rows(int.raw.names.gbif)))
print("unresolved unique scientific names ")
print(length(unique(unresolved_species(int.raw.names.gbif)$scientific_name.raw)))

```




--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Scientific Name Changes: Low Confidence Matches on scientific name

**OPTIONAL**

this may no longer be necessary since ~ 50 species to resolve after
applying the high-confidence resolutions. 


Extract scientific name matches with lower confidence (match_score <= 0.90) 
for those remaining species that didn't match for further 
checking

```{r}

# low_confidence_matches <- scientific_name_matches %>%
#   filter(
#     (scientific_name_match_score < 0.9 & !is.na(scientific_name_match_score)) 
#   ) %>% 
#   filter( # remove unid species from matches
#     !grepl(" sp\\.$", closest_scientific_name_match)
#   ) %>% 
#   filter(
#     scientific_name.raw %in% unresolved_species(int.raw.names)$scientific_name.raw
#   ) 
# 
#   # couldn't get Mutate to work, so here is a loop to add in the common name where it's found
#   low_confidence_matches$common_name.checklist <- NA
#   for(r in 1:nrow(low_confidence_matches)){
#     common_names <- filter(checklist,scientific_name == low_confidence_matches[r,"closest_scientific_name_match"] & category == "species")$common_name
#     if(length(common_names)==1) low_confidence_matches[r,"common_name.checklist"]<- common_names[1]
#   }
# 
# 
# length(unique(low_confidence_matches$scientific_name.raw))
```

previously 69 out of 326 - checks out OK; May 29, 2025: 65
Sept 2025: 9 




Scroll through these Low Confidence Matches in order from highest to lowest

Assigning closest low-confidence match with update notes,
and will be updated if necessary below




--------------------------------------------------------------------------------

## Unid : Genus-only species fixes


Open the Unid sp. (Genu-only) to work on:

Number of un-id names (genera only, not expected to Taxadb to match, just accounting):

```{r}
int.raw.names.unid <- filter(int.raw.names, grepl(" sp\\.$", scientific_name.edit))
print(paste("rows:", nrow(int.raw.names.unid)))
print(paste("unique:", length(unique(int.raw.names.unid$scientific_name.edit))))

```




--------------------------------------------------------------------------------


## SUMMARY Examine Name Corrections and Notes so far

*TO-DO: move this into a function so can be called at each step in workflow

Total number of name combinations in database:


```{r}
#| echo: false
#| output: true

print(nrow(int.raw.names))

```

number of full species without notes (dispensation/edits) :

```{r}
#| echo: false
#| output: true

print(nrow(unresolved_species(int.raw.names)))

```

number of all rows without notes (dispensation/edits) including Unid.:

```{r}
#| echo: false
#| output: true

print( nrow( filter(int.raw.names, is.na(edit_notes))))

```


### checkpoint save
```{r}
#| echo: false
#| output: true

# today_date_string <- format(Sys.Date(),"%Y-%m-%d")
# rdata_file_name <- paste0("AvianInteractionData_L1_workspace", today_date_string, ".RData")
# f <- file.path(file_paths$L1,rdata_file_name )
# save.image(f)
# 
# print(paste("whole enviroment saved as ", f))

```





--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

## Manual Taxanomic Edits

Not all automatic fixes were correct or some simply must be determined 
manually. These are collected in a CSV file with the same columns as our `int.raw.names`
data frame with columns

scientific_name.raw : name to match our name edits table 
common_name.raw : used primarily for reference when building the table
scientific_name.edit : the scientific name to apply in final output after review and decision
edit_notes : the reasoning why the scientific name was chosen to apply to the final output
comments : internal notes used to help build this table, not used in final output

These edits are apply on top of the 'edits' table built by automatic processes 
above. Some of these are 'overrides' where an entry applied automatically (e.g.
high confidence common name) was incorrect but easier to apply and correct here or
a typo that would be impossible for an automatic process to detect. 

There is code above to create a version of this table to start with if there is 
not such a table, based on the species that are not resolved so far but inserts 
the confidence of the matches in the comments field.  That may be used to 
create an additional table with new rows that can be copied/pasted into 
the main table with existing name resolution decisions

At the end of this process, a final name resolution table is output which includes
all of the name resolutions include those 

**TO-DO**

1. complete the entries in this file - PLZ completed 10/5/2025; LM confirmed 12/11/2025
3. read in the file and verify all rows are ok, filter out unfinished rows
4. apply the edits in the file regardless if there is already a note since 
   these may override the automatic resolutions
   
First step, check that the path to the manual resolutions file is named in a 
variable and that the file exists.  

If it does not this process will skip to the end leaving some species unresolved. 

```{r}
#| label: read_manual_resolutions
manual_taxonomic_resolutions <- data.frame()

if(file.exists(manual_taxonomic_resolutions_file_name)) {
  manual_taxonomic_resolutions <- read_csv(manual_taxonomic_resolutions_file_name, show_col_types = FALSE) 
} else {
  warning(paste("Manual taxonomic resolutions file not found", manual_taxonomic_resolutions_file_name))
  # couldn't find the file but keep going and check if we have an empty data frame
}

manual_taxonomic_resolutions <- filter(manual_taxonomic_resolutions, !is.na(scientific_name.edit))
print(paste("read in ", nrow(manual_taxonomic_resolutions), "manual name resolutions"))
```

**Manual Taxonomic Resolution Workflow: **

Goal is to accumulate a list of fixes and notes

1. review existing edits below
   use a lookup function to see if an edit (raw -> edit, common name) is still needed

1. Review the outputs of various steps of corrections
   The lower-confidence matches that may be skipped are a good source of 
How to to add an edit/adjustment to the list:

1. Preferred: add the entry in the file
1. call the `add_name_edits` function with arguments including the data frame
   used to collect these edits (`int.raw.names`, see above) directly

1. add to this list below with the arguments in the following order, which are 
   added one by one calling that `add_name_edits` function
  
   - original scientific_name (raw) as appears in interaction file, 
   - editing notes, dispensation or why an edit is needed or d, 
   - (optional) scientific_name.edit IF the name is changed
   - (optional) common_name.edit if the name was changed 



```{r}
#| label: apply_manual_resolutions

int.raw.names.manual <- int.raw.names
for(r in 1:nrow(manual_taxonomic_resolutions)){
  manual.edit = manual_taxonomic_resolutions[r,]
  matching_rows = which(int.raw.names.manual$scientific_name.raw == manual.edit$scientific_name.raw)
  # TODO check if r is a real vector of integers
  if(length(matching_rows) == 0){
    # manual edited raw species is not in L0 data, may be left over,
    not_found_msg <- paste(manual.edit$scientific_name.raw, ": this raw /L0 species in manual edits table no longer found in L0 data" )
    warning(not_found_msg)
  } else {
    int.raw.names.manual[matching_rows,]$scientific_name.edit <- manual.edit$scientific_name.edit
    int.raw.names.manual[matching_rows,]$edit_notes <- manual.edit$edit_notes
  }

}

```

Remaining species to manual resolve after fuzzy and gbif matching:

```{r}
#| echo: false
#| output: true
print("unresolved rows in names table:")
print(length(unresolved_species_rows(int.raw.names.manual)))
print("unresolved unique scientific names ")
print(length(unique(unresolved_species(int.raw.names.manual)$scientific_name.raw)))

```

To view, run View(unresolved_species(int.raw.names.manual))

If updating the CSV, re-run from chunk `read_manual_resolutions`

After review, save this list to the main name resolution data frame

```{r}
int.raw.names <- int.raw.names.manual

```


review data frame to make decisions

```{r}
# make additional edits using int.raw.names <- add_name_edits(...)
# re-run the block subset_check

```


### Subspecies

check if there are any subspecies remaining that have interactions

for those, decide what to do with them if they exist, potentially publish in the 
database


```{r}
#| eval: false


```


### Work through hybrids 

```

Hybrids to standardize: 
  
  TO-DO: keep them in the database, but fix only the following 

  Hybrid Bullock's Oriole X Baltimore = Oriole Icterus bullockii x galbula
  Hybrid Western Gull X Glaucous-Winged Gull = Larus occidentalis x glaucescens
  Hybrid Barnacle X Bar-Headed Goose = Branta leucopsis x anser indicus

dplyr::filter(int.raw, species1_scientific %in% c("Branta leucopsis x"))
# NO HYBRIDS IN CLEANED DATA NOW
dplyr::filter(int.raw, species1_scientific %in% c("Branta leucopsis x Anser indicus"))
dplyr::filter(int.raw, species2_scientific %in% c("Branta leucopsis x Anser indicus"))
# dplyr::filter(unresolved.gbif, scientific_name.edit %in% c("Branta leucopsis x anser indicus"))
# dplyr::filter(unresolved.gbif, scientific_name.edit %in% c("Branta leucopsis x anser indicus"))
# fixed_names1$scientific_name[fixed_names1$scientific_name.edit == "Branta leucopsis x anser indicus"] <- "Branta leucopsis x Anser indicus"
```



## Merge and Save data

Update resolved common names use the Clements/eBird 2024 checklist to assign common names (by referencing the official scientific name; all fixed above)

```{r}
# mutate is terrible at joining things and I only want to join common name
for(r in 1:nrow(int.raw.names)){
  common_name.checklist <- checklist[checklist$scientific_name == int.raw.names[r,]$scientific_name.edit,]$common_name
  if(length(common_name.checklist) > 0 ) { # match 
    int.raw.names[r,]$common_name.edit <- common_name.checklist
  }
}

```

Update the scientific names in the interactions data with our table as much 
as possible: 

```{r}
# make a copy of the database data frame so we can re-run if necessary
int.raw.resolved <- int.raw

updated_rows <- c()

for(r in 1:nrow(int.raw.names)){
  # if no resolution discovered, skip (for now - ultimately all are updated)
  if(is.na(int.raw.names[r,"scientific_name.edit"])){
    next
  }
  
  # extract values from data frame for readability
  scientific_name.raw <- int.raw.names[r,]$scientific_name.raw
  scientific_name.edit <- int.raw.names[r,]$scientific_name.edit
  common_name.edit <- int.raw.names[r,]$common_name.edit
  
  # update sp1s and sp2s
  # use matches from original dataframe but update our resolved data frame 
  # since the rows are the same order and number 
  # this allows for matching on the raw sci name for common name updates, 
  # even after it's been updated
  
  updated_sp1_rows = which(int.raw$species1_scientific == scientific_name.raw)
  if(length(updated_sp1_rows) > 0){
    int.raw.resolved[updated_sp1_rows, ]$species1_scientific <- scientific_name.edit
    int.raw.resolved[updated_sp1_rows, ]$species1_common <- common_name.edit
    updated_rows <- union(updated_rows, updated_sp1_rows)
  }

  updated_sp2_rows = which(int.raw$species2_scientific == scientific_name.raw)
  if(length(updated_sp2_rows) > 0){
    int.raw.resolved[updated_sp2_rows, ]$species2_scientific <- scientific_name.edit
    int.raw.resolved[updated_sp2_rows,  ]$species2_common <- common_name.edit
    updated_rows <- union(updated_rows, updated_sp2_rows)
  }
  
}

print(length(updated_rows))
```

Review the updated database using `View(int.raw.resolved)`  The original is still in `int.raw`

Some manual updates for Northwestern Crow (common name doesn't exist anymore but the data still contain the subspecies; re-assign to American Crow)
```{r}

int.raw.resolved$species1_scientific[int.raw.resolved$species1_scientific == "Corvus brachyrhynchos caurinus"] <- "Corvus brachyrhynchos"

int.raw.resolved$species1_common[int.raw.resolved$species1_scientific == "Corvus brachyrhynchos"] <- "American Crow"

int.raw.resolved$species2_scientific[int.raw.resolved$species2_scientific == "Corvus brachyrhynchos caurinus"] <- "Corvus brachyrhynchos"

int.raw.resolved$species2_common[int.raw.resolved$species2_scientific == "Corvus brachyrhynchos"] <- "American Crow"
```

```{r}
# after review, copy int.raw.resolved to main variable 

int.raw <- int.raw.resolved

```
## Database Summary

```{r}

print("unique scientific names = number of unique species in this database")
print(length(union(int.raw$species1_scientific, int.raw$species2_scientific)))


print("unique types of interactions")
print(length(unique(int.raw$interaction))) #36 (37 with manual fixes)

print("unique pairwise interactions") #19417 (non-manual fixes); 19403 with manual fixes

# if you want to ignore the order of species, we will need to create pairs and sort them
# some sample code saved here to consider: 
# dat <- data.frame(c('a','b','c'), c('b','a','d'), stringsAsFactors=F );
# colnames(dat) <- c('s1','s2');
# x <- unique(as.data.frame(t(apply(dat, 1, sort ))));
# rownames(x) <- 1:nrow(x);
# x;
print(length(unique(paste(int.raw$species1_scientific, int.raw$species2_scientific))))

# edit to report number of unique rows by DATA$species1_scientific, DATA$species2_scientific, DATA$interaction

```


Save Results to CSV

```{r}
#| label: save_output
#| echo: false
#| output: true

# set these variables here for flexibility if the workflow changes 
interaction_data <- int.raw
taxonomic_resolutions<- int.raw.names

# AvianInteractionData_L1_file and AvianInteractionData_L1_taxonomy_table is set at the top of this file

f <- file.path(file_paths$L1, AvianInteractionData_L1_file )
write_csv(interaction_data, f)
print(paste("interaction database saved to ", f))

f<- file.path(file_paths$L1, AvianInteractionData_L1_taxonomy_table_file )
write_csv(taxonomic_resolutions, f)
print(paste("taxonomic_resolutions_file saved to ", f))

```


## Subset to the checklist 

This should go into a different script/notebook

Analysis Paper: 

1 sp1 and sp2 on checklist (canada CONUS)
Data Paper Goal: 

1. Sp1 or sp2 needs to be on Checklist (canada alaska conus checklist)
2. Final check:which rows are not (sp1 AND sp2 on Canada Alaska Conus checklist)?
    how many?
    which of these are NOT on full clements list
    how many? 
    review data
    check against all clements
    assume names are fixed via gbif/taxa db
    
    if descions are made add name edits to be added to the int.raw.names list above



```{r}
#| label: subset_check
# rcode for above, prints a data frame of non-checklist rows
```
